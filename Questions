描述
输入n个整数的序列，要求对这个序列进行去重操作。所谓去重，是指对这个序列中每个重复出现的整数，只保留该数第一次出现的位置，删除其余位置。
输入描述：
输入包含两行，第一行包含一个正整数n（1 ≤ n ≤ 1000），表示第二行序列中数字的个数；第二行包含n个整数（范围1~5000），用空格分隔。

输出描述：
输出为一行，按照输入的顺序输出去重之后的数字，用空格分隔。

示例1
输入：
5
10 12 93 12 75
复制
输出：
10 12 93 75
#include<stdio.h>
// //暴力求解法，存在问题，无法满足，按照原来的输入顺序来输出，经历了一次排序
// int main()
// {
//     int n=0;
//     int arr[1000]={0};
//     int i=0;
//     scanf("%d",&n);
//     //接受n个数字
//     for(i=0;i<n;i++)
//     {
//         scanf("%d",&arr[i]);
//     }
//     //处理
//     //1.排序  用冒泡排序实现
//     for(i=0;i<n;i++)//趟数
//     {
//         int j=0;
//         for(j=0;j<n-1-i;j++)//每次排好后面一个

//         if(arr[j]>arr[j+1])
//         {
//             int tmp=arr[j];
//             arr[j]=arr[j+1];
//             arr[j+1]=tmp;
//         }
//     }
//     //2.去重  最多比较n-1对
//     //例如 5 3 3 4 2 2
//     //排序成了 2 2 3 3 4 5
//     for(i=0;i<n-1;i++)
//     {
//         if(arr[i]==arr[i+1])
//         {
//            //把从i+1下标往后的元素全部往前覆盖
//             int k=0;
//             for(k=i;k<n-1;k++)
//             {
//                 arr[k]=arr[k+1];
//             }
//             n--;//去重后整体元素个数减少
//             i--;//防止2 3 3 3变为2 3 3这种情况，还得从该处进行比较
//         }

//     }
//     //3.打印
//     for(i=0;i<n;i++)
//     {
//         printf("%d ",arr[i]);
//     }
//     return 0;
// }
//所以我们换另一种不需要排序的方法
//这个方法特别的秀
//先申请一个有1001个元素的数组，arr[1001]，例如拿到一个数字10时，10表示它将放进的元素的下标，就把10存在arr[10]中，再次拿到
//10时还是存在arr[10]中，哈哈哈哈，因为下标不可能有相同的，所以这个大数组中不可能有重复出现的数字
//申请一个1001个元素的数组，是为了下标中出现1000，打印的时候碰到，数值为0的元素就放弃打印，只打印不为0的元素
// int main()
//{
//     int n=0;
//     int arr[1001]={0};//1001
//     scanf("%d",&n);
//     //接受n个数字
//     int i=0;
//     int m=0;
//     for(i=0;i<n;i++)
//     {
//         scanf("%d",&m);
//         arr[m]=m;
//     }
//     for(i=0;i<1001;i++)
//     {
//         if(arr[i]!=0)
//         {
//             printf("%d ",arr[i]);
//         }
//     }
//     return 0;
// }
//下面这段改进的代码，用了两个数组，完全符合题目要求的按输入顺序输出，非常的perfect
int main()
{
    int n=0;
    int arr[1001]={0};//1001
    int arr1[1000]={0};
    scanf("%d",&n);
    //接受n个数字
    int i=0;
    int m=0;
    int k=0;
    for(i=0;i<n;i++)
    {
        scanf("%d",&m);
        if(arr[m]==0)
        {
           arr1[k]=m;
            k++;
        }
        arr[m]=m;
    }
    for(i=0;i<k;i++)
    {
        printf("%d ",arr1[i]);   
    }
    return 0;
}


KiKi学习了结构体和指针，他了解了结构体类型可以定义包含多个不同类型成员，而指针本质是内存地址，
是引用数据的另外一种方式。现在他想将多个输入的数据通过结构体和指针的方式连接在一起，
形成一个单向链表，即：每个结点是结构体类型，包括整型数据成员（data）和结构体指针类型成员（next），
每个结点的指针部分指向下一个输入的结点。具体建立过程如下：先输入n个整数，按照数据输入的顺序建立一个带头结点的单链表
，再输入一个数据m,将单链表中的值为m的结点全部删除。输出删除后的单链表信息。
#include <stdio.h>
//链表是一种数据结构，数据结构是描述数据在内存中的存储方式
//每一个结点，包含两部分，第一部分，包含数据叫做数据域，第二部分包含地址，叫做指针域
//链表结点的定义
struct Node
{ 
  int data;//数据域
  struct Node* next;//指针域
     
};//struct 后面一定不要忘了加；分号
int main()
{
    struct Node* list=NULL;//指向链表的指针，先置成空指针
    //输入n
    int n=0;
    scanf("%d",&n);
    int i=0;
    int m=0;
    int d=0;
    //接受n个数字并尾部插入到单链表中
    struct Node* tail=NULL;//这里再定义一个tail指针,tail指针每次记录上一个结点的地址，方便你将上一个结点的next赋值，方便我们往下写，虽然我平时不喜欢这样写
    for(i=0;i<n;i++)
    {
        scanf("%d",&m);
        struct Node* pn=(struct Node*)malloc(sizeof(struct Node));
        pn->data=m;
        pn->next=NULL;
        //分为插入第一个元素
        if(list==NULL)
        {
          list=pn;
          tail=pn;
        }
        //插入不是第一个元素
        else
        {
            tail->next=pn;
            tail=pn;//把tail传递下去z
        }
    }
    //接收要删除的元素
    scanf("%d",&d);
    //删除链表中指定的元素
    struct Node* cur=list;
    struct Node* prev=NULL;
    while(cur!=NULL)//啥都没存直接不进入
    {   
        //找到了等于d的data
    if(cur->data==d)
        {
           //删除
           //删除的如果是第一个结点
           struct Node* pd=cur;
            if(cur==list)
           {    
               list=list->next;
                cur=list;
           }
            else
            {
                prev->next=cur->next;
                cur=prev->next;
            }
            free(pd);
            n--;//结点个数减少
        }
     else
     {  
             prev=cur;
             cur=cur->next;
     }
    }
    //输出链表
    printf("%d\n",n);
    cur=list;
    while(cur!=NULL)
    {
        printf("%d ",cur->data);
        cur=cur->next;
    }
    //释放链表
    cur=list;
    struct Node* del=NULL;
    while(cur!=NULL)
    {
       del=cur;
       cur=cur->next;
       free(del);
    }
    return 0;
}

int main()
{
    int n=0;
    int i=0;
    int sum=0;
    int ret=1;
    scanf("%d",&n);
   for(;n>=1;n--)
{
     ret=1;
    for(i=1;i<=n;i++)
    {
       ret=ret*i;//此处结算阶乘，还有很大的简化空间，首先，2！为1*2   3！为1*2*3 每一次求阶乘都是从最小的1开始乘，其实只需要在上一个的基础上，乘n便可
    }
  sum=sum+ret;
}
printf("%d",sum);
return 0;
} 


以下为简化写法
int main()
    {
        int n=0;
        int ret=1;
        int sum=0;
        scanf("%d",&n);
        for(int i=1;i<=n;i++)
      {
            ret=ret*i;
            sum+=ret;
       }
    return 0;
    }

例题 在一个有序数组中查找具体的某个数字n
int main()
{
    int arr[]={1,2,3,4,5,6,7,8,9,10};
    int k=7;
    //写一个代码，在arr有序数组中找到7
        int i=0;
int sz=sizeof(arr)/sizeof(arr[0]);
for(i=0;i<sz;i++)
{
    if(k==arr[i])
    {
        printf("找到，下标为："%d",i);
        break;//break只是单纯的跳出循环
     }
}
if(sz==i)
  { 
    printf("没找到");
  }
return 0;
}

在有序数组的条件下这样找太麻烦了
1 2 3 4 5 6 7 8 9 10
假如是n个元素，最坏的情况是找n次

二分查找
所以我们在有序的情况下，采取二分查找算法
假如要从有序数组中找7，那么先从最中间开始找，最中间是5，7大于5，故范围缩小到右半部分的6-10
6-10再取中间的8
1 2 3 4 5 6 7 8 9 10 元素
0 1 2 3 4 5 6 7 8  9  下标 
下标取平均值，0+9除以2，等于4，去取下标为4的元素拿来比较
二分查找的时间复杂度为log2N
逐个查找的时间复杂度为N

int main()
{
    int arr[]={1,2,3,4,5,6,7,8,9,10};
    int k=7;
    int sz=sizeof(arr)/sizeof(arr[0]);//计算元素个数
    int left=0;//左下标
    int right=sz-1;//右下标
    while(left<=right)
{
   int mid=(left+right)/2;
    if(arr[mid]>k)
    {
        right=mid-1;
    }
    else if(arr[mid]<k)
    {
        left=mid+1;
    }
    else
    {
        printf("找到了,下标为：%d"，mid);
        break;
    }
}
  if(left>right)//防止break跳出循环来到这里也打印找不到
  {
     printf("找不到");
  }
return 0;
}

例题 打印循环移动的welcome to bit！
                   #####welcome to bi
直接用两个字符数组来完成
char arr1[]= "welcome to bit！"                       char 定义数组时，必须说明数组中元素的类型
                                                                    []里不写大小，要用多少空间就会自动开辟多少
char arr2[]=" #############"
int left=0;
int right=sizeof(arr1)/sizeof(arr[0])-1//这样写是错误的
//int main()
//{
//	int m = 0;
//	int n = 0;
//	scanf_s("%d,%d", &m, &n);//0没有最大公约数
//		while (m % n)//m%n为0时，判断为假，自动跳出，n就是最大公约数，为非0时，循环1继续,注意俩个数之间必有最大共约束，毕竟每个数都可以除以1，至少有1这个公约数
//		{
//			int r = m % n;
//			m = n;
//			n = r;
//		}
//		printf("%d", n);
//	
//	return 0;
//}
//int main()
//{
//	int year = 0;
//	//顺便记录一下闰年的个数
//	int count = 0;
//	for (year = 1000; year <= 2000; year++)
//	{
//		////判断year是否为闰年
//		////1.能被4整除，并且不能被100整除是闰年
//		////2.能被400整除是闰年
//		//if (year % 4 == 0 && year % 100 != 0)
//		//{
//		//	printf("%d", year);
//		//	count++;
//		//}
//		//else if (year % 400 == 0)
//		//{
//		//	printf("%d", year);
//		//	count++;
//		//}
//		//以下为简化写法
//		if ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0))
//		{
//			printf("%d ", year);
//			count++;
//		}
//	}
//	printf("%d", count);
//	return 0;
//}
//int main()
//{
//	int i = 0;
//	int count = 0;
//	for (i = 100; i <= 200; i++)//初始化给i赋值100，此时int i变量的值就是100
//	{
//		//判断i是否为素数
//		//素数判断规则，素数只能被1和它本身整除
//		//1.试除法 假如能被不是1和它本身的数字整除就不是素数
//		//首先，要产生2到i-1的数字
//		int j = 0;
//		for (j = 2; j <= i - 1; j++)
//		{
//			if (i % j == 0)
//			{
//				break;
//			}
//		}
//		if (j == i)
//		{
//			printf("%d ", i);
//			count++;
//		}
//
//	}
//	printf("\n%d\n", count);
//	return 0;
//}
//优化写法
int main()
{
    int i = 0;
    int count = 0;
    for (i = 100; i <= 200; i++)
    {
       
        int j = 0;
        for (j = 2; j <= sqrt(i); j++)
        {
            if (i % j == 0)
            {
                break;
            }
        }
        if (j>sqrt(i))
        {
            printf("%d ", i);
            count++;
        }
    }
    printf("\n%d\n", count);
    return 0;
}
